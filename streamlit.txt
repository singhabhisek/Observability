import streamlit as st
import plotly.express as px
import requests
import pandas as pd
from datetime import datetime, timedelta

# Dynatrace API Configuration
DT_API_TOKEN = "YOUR_DYNATRACE_API_TOKEN"
DT_ENVIRONMENT_ID = "YOUR_ENVIRONMENT_ID"
BASE_URL = f"https://{DT_ENVIRONMENT_ID}.live.dynatrace.com/api/v2"

# Function to fetch CPU & Memory usage
def fetch_dynatrace_metrics():
    headers = {
        "Authorization": f"Api-Token {DT_API_TOKEN}"
    }
    
    # Dynatrace Metric API Query
    metrics_query = "builtin:host.cpu.usage,builtin:host.mem.usage"
    time_from = (datetime.utcnow() - timedelta(minutes=60)).isoformat() + "Z"
    time_to = datetime.utcnow().isoformat() + "Z"
    
    url = f"{BASE_URL}/metrics/query?metricSelector={metrics_query}&from={time_from}&to={time_to}&resolution=1m"
    
    response = requests.get(url, headers=headers)
    
    if response.status_code == 200:
        data = response.json()
        return data["result"]
    else:
        st.error(f"Failed to fetch data: {response.text}")
        return None

# Streamlit UI
st.title("Dynatrace Observability Dashboard")

# Fetch Data
data = fetch_dynatrace_metrics()

if data:
    # Transform data into DataFrame
    metrics_data = []
    for metric in data:
        metric_name = metric["metricId"]
        for series in metric["data"]:
            for point in series["values"]:
                metrics_data.append({
                    "timestamp": datetime.utcfromtimestamp(point["timestamp"] / 1000).strftime("%Y-%m-%d %H:%M:%S"),
                    "metric": metric_name,
                    "value": point["value"]
                })
    
    df = pd.DataFrame(metrics_data)

    # Line Chart for CPU & Memory Usage
    fig = px.line(df, x="timestamp", y="value", color="metric", title="CPU & Memory Usage Over Time")
    st.plotly_chart(fig, use_container_width=True)

    # Show Data Table
    st.subheader("Raw Metrics Data")
    st.dataframe(df)



import streamlit as st
import plotly.express as px
import pandas as pd
import random

# Generate Dummy Data
data = [
    {"timestamp": f"2025-03-03 12:{i:02d}", "response_time": random.randint(100, 500),
     "cpu_usage": random.uniform(10, 90), "memory_usage": random.uniform(30, 80),
     "status_code": random.choice([200, 400, 500]), "application": random.choice(["Desktop", "Mobile"]),
     "transaction": random.choice(["Login", "Checkout", "Add to Cart", "Logout"])}
    for i in range(60)
]
df = pd.DataFrame(data)

# Streamlit App
st.set_page_config(layout="wide", page_title="Observability Dashboard")

st.title("Observability Dashboard")

# Filters
col1, col2, col3, col4 = st.columns(4)
with col1:
    app_filter = st.selectbox("Select Application", ["All"] + list(df["application"].unique()))
with col2:
    status_filter = st.selectbox("Select Status Code", ["All"] + list(df["status_code"].unique()))
with col3:
    start_date = st.date_input("From Date")
with col4:
    end_date = st.date_input("To Date")

st.button("Search")

# KPI Metrics
col1, col2, col3 = st.columns(3)
col1.metric("Avg CPU Utilization", f"{df['cpu_usage'].mean():.2f}%")
col2.metric("Avg Memory Utilization", f"{df['memory_usage'].mean():.2f}%")
col3.metric("Total Errors", f"{(df['status_code'] != 200).sum()}")

# Charts Section
col1, col2, col3 = st.columns(3)

# HTTP Status Code Pie Chart
fig_pie = px.pie(df, names='status_code', title="HTTP Status Codes")
col1.plotly_chart(fig_pie, use_container_width=True)

# Server Hits Pie Chart
fig_server = px.pie(df, names='application', title="Server Hits", hole=0.4)
col2.plotly_chart(fig_server, use_container_width=True)

# CPU Usage Line Chart
fig_cpu = px.bar(df, x='timestamp', y='cpu_usage', title="CPU Usage")
col3.plotly_chart(fig_cpu, use_container_width=True)

# Lower Charts
col1, col2, col3 = st.columns(3)

# Transaction Response Time Line Chart
fig_response = px.line(df, x='timestamp', y='response_time', title="Transaction Response Time")
col1.plotly_chart(fig_response, use_container_width=True)

# TPS Over Time Line Chart
fig_tps = px.line(df, x='timestamp', y='response_time', color='transaction', title="TPS Over Time")
col2.plotly_chart(fig_tps, use_container_width=True)

# Memory Usage Chart
fig_memory = px.line(df, x='timestamp', y='memory_usage', title="Memory Usage")
col3.plotly_chart(fig_memory, use_container_width=True)

# Transactions Table
st.subheader("Transactions")
st.dataframe(df[['transaction', 'response_time']])

# Logs Table
st.subheader("Logs")
st.dataframe(df[['timestamp', 'application', 'status_code']])
